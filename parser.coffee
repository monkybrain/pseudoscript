class Parser

  constructor: (map, dictionary) ->
    @map = map
    @dictionary = dictionary

    # Set scope to universe
    @scope = 'universe'

  question: (line, subtype) ->
    # find class
    for model in @map.concretes
      null
    # syntax = @dictionary.types.questions[subtype].syntax
    "console.log rooms"

  vp: (line) ->

    ### VERB PHRASE ###
    vp =
      verb: null
      object: null
      indirect: null
      ref: ''

    ### Find reference ###
    match = line.match /called '.*'/
    if match?
      phrase = line.slice match.index
      vp.ref = phrase.replace("called", "").trim()


    ### Find indirect object ###
    for entry, body of @dictionary.prepositions
      for pattern in body.patterns
        match = line.match pattern
        if match?
          # Unuglify!!!
          phrase = line.slice(match.index)
          line = line.slice 0, line.lastIndexOf(phrase)
          indirect = phrase.slice pattern.length + 1
          for model in @map.concretes
            match = indirect.match model.lexical.word
            if match?
              if model.scope?
                vp.indirect = model.scope
              else
                vp.indirect = null
              break

    ### Find object ###
    for model in @map.concretes
      match = line.match model.lexical.word
      if match?
        vp.object = model
        break

    ### Find verb ###
    for entry, body of @dictionary.verbs
      for pattern in body.patterns
        match = line.match body.pattern
        if match?
          vp.verb = body.syntax
          break

    if vp.verb?
      vp.verb(@scope, vp.object, vp.ref, vp.indirect)

  type: (line) ->

    sentence = {
      type: 'declarative'
      subtype: null
    }

    # Check if question
    for key, value of @dictionary.types.questions
      for pattern in value.patterns
        match = line.match pattern
        if match?
          sentence.type = 'question'
          sentence.subtype = key

    sentence

  parse: (line) ->

    ### Remove ignored words ###
    for word in @dictionary.ignore
      line = line.replace "#{word} ", ""

    ### Find sentence type ###
    sentence = @type line

    if sentence.type is 'question'
      return @question line, sentence.subtype
    else
      return @vp line

  wrap: (lines, comments, path) ->

    # New document
    document = []

    # Header
    document.push "\n### Generated by PseudoScript 0.0.1 ###\n"

    # Imports
    document.push "\n### Imports ###"
    document.push "map = require '#{path}'"
    document.push "\n# Abstracts #"
    document.push "Universe = map.abstracts.Universe"
    document.push "Noun = map.abstracts.Noun"
    document.push "\n# Concretes #"
    document.push "Room = map.concretes[0]"
    document.push "Light = map.concretes[1]\n"
    document.push "rooms = []"
    document.push "lights = []"

    document.push "\n\n\n### Code ###\n"

    document.push "# So you think you're god..."
    document.push "universe = new Universe()\n"

    # Combine comments and code
    combined = []
    for i in [0...comments.length]
      combined.push "# #{comments[i]}\n#{lines[i]}\n"

    # Push body
    document.push combined.join "\n"

    # Join and return
    document.join "\n"

    # TODO: Pull from source file instead!
    ###
    for model in @map.abstracts
      console.log model.toString()
    for model in @map.concretes
      console.log model.toString()
    ###

module.exports = Parser