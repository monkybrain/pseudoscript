// Generated by CoffeeScript 1.10.0
(function() {
  var Parser;

  Parser = (function() {
    function Parser(map, dictionary) {
      this.map = map;
      this.dictionary = dictionary;
      this.scope = 'universe';
    }

    Parser.prototype.parse = function(line) {

      /* Remove ignored words */
      var body, entry, indirect, j, k, l, len, len1, len2, len3, len4, m, match, model, n, pattern, phrase, ref, ref1, ref2, ref3, ref4, ref5, ref6, vp, word;
      ref = this.dictionary.ignore;
      for (j = 0, len = ref.length; j < len; j++) {
        word = ref[j];
        line = line.replace(word + " ", "");
      }

      /* VERB PHRASE */
      vp = {
        verb: null,
        object: null,
        indirect: null,
        ref: ''
      };

      /* Find reference */
      match = line.match(/called '.*'/);
      if (match != null) {
        phrase = line.slice(match.index);
        vp.ref = phrase.replace("called", "").trim();
      }

      /* Find indirect object */
      ref1 = this.dictionary.prepositions;
      for (entry in ref1) {
        body = ref1[entry];
        ref2 = body.patterns;
        for (k = 0, len1 = ref2.length; k < len1; k++) {
          pattern = ref2[k];
          match = line.match(pattern);
          if (match != null) {
            phrase = line.slice(match.index);
            line = line.slice(0, line.lastIndexOf(phrase));
            indirect = phrase.slice(pattern.length + 1);
            ref3 = this.map.concretes;
            for (l = 0, len2 = ref3.length; l < len2; l++) {
              model = ref3[l];
              match = indirect.match(model.lexical.word);
              if (match != null) {
                if (model.scope != null) {
                  vp.indirect = model.scope;
                } else {
                  vp.indirect = null;
                }
                break;
              }
            }
          }
        }
      }

      /* Find object */
      ref4 = this.map.concretes;
      for (m = 0, len3 = ref4.length; m < len3; m++) {
        model = ref4[m];
        match = line.match(model.lexical.word);
        if (match != null) {
          vp.object = model;
          break;
        }
      }

      /* Find verb */
      ref5 = this.dictionary.verbs;
      for (entry in ref5) {
        body = ref5[entry];
        ref6 = body.patterns;
        for (n = 0, len4 = ref6.length; n < len4; n++) {
          pattern = ref6[n];
          match = line.match(body.pattern);
          if (match != null) {
            vp.verb = body.syntax;
            break;
          }
        }
      }
      if (vp.verb != null) {
        return vp.verb(this.scope, vp.object, vp.ref, vp.indirect);
      }
    };

    Parser.prototype.wrap = function(lines, comments, path) {
      var combined, document, i, j, ref;
      document = [];
      document.push("\n### Generated by PseudoScript 0.0.1 ###\n");
      document.push("\n### Imports ###");
      document.push("map = require '" + path + "'");
      document.push("\n# Abstracts #");
      document.push("Universe = map.abstracts.Universe");
      document.push("Noun = map.abstracts.Noun");
      document.push("\n# Concretes #");
      document.push("Room = map.concretes[0]");
      document.push("Light = map.concretes[1]");
      document.push("\n\n\n### Code ###\n");
      document.push("# So you think you're god...");
      document.push("universe = new Universe()\n");
      combined = [];
      for (i = j = 0, ref = comments.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        combined.push("# " + comments[i] + "\n" + lines[i] + "\n");
      }
      document.push(combined.join("\n"));
      return document.join("\n");

      /*
      for model in @map.abstracts
        console.log model.toString()
      for model in @map.concretes
        console.log model.toString()
       */
    };

    return Parser;

  })();

  module.exports = Parser;

}).call(this);
