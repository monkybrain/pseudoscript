// Generated by CoffeeScript 1.10.0
(function() {
  var Parser;

  Parser = (function() {
    function Parser(map, dictionary) {
      this.map = map;
      this.dictionary = dictionary;
      this.scope = 'universe';
    }

    Parser.prototype.question = function(line, subtype) {
      var j, len, model, ref;
      ref = this.map.concretes;
      for (j = 0, len = ref.length; j < len; j++) {
        model = ref[j];
        null;
      }
      return "console.log rooms";
    };

    Parser.prototype.vp = function(line) {

      /* VERB PHRASE */
      var body, entry, indirect, j, k, l, len, len1, len2, len3, m, match, model, pattern, phrase, ref, ref1, ref2, ref3, ref4, ref5, vp;
      vp = {
        verb: null,
        object: null,
        indirect: null,
        ref: ''
      };

      /* Find reference */
      match = line.match(/called '.*'/);
      if (match != null) {
        phrase = line.slice(match.index);
        vp.ref = phrase.replace("called", "").trim();
      }

      /* Find indirect object */
      ref = this.dictionary.prepositions;
      for (entry in ref) {
        body = ref[entry];
        ref1 = body.patterns;
        for (j = 0, len = ref1.length; j < len; j++) {
          pattern = ref1[j];
          match = line.match(pattern);
          if (match != null) {
            phrase = line.slice(match.index);
            line = line.slice(0, line.lastIndexOf(phrase));
            indirect = phrase.slice(pattern.length + 1);
            ref2 = this.map.concretes;
            for (k = 0, len1 = ref2.length; k < len1; k++) {
              model = ref2[k];
              match = indirect.match(model.lexical.word);
              if (match != null) {
                if (model.scope != null) {
                  vp.indirect = model.scope;
                } else {
                  vp.indirect = null;
                }
                break;
              }
            }
          }
        }
      }

      /* Find object */
      ref3 = this.map.concretes;
      for (l = 0, len2 = ref3.length; l < len2; l++) {
        model = ref3[l];
        match = line.match(model.lexical.word);
        if (match != null) {
          vp.object = model;
          break;
        }
      }

      /* Find verb */
      ref4 = this.dictionary.verbs;
      for (entry in ref4) {
        body = ref4[entry];
        ref5 = body.patterns;
        for (m = 0, len3 = ref5.length; m < len3; m++) {
          pattern = ref5[m];
          match = line.match(body.pattern);
          if (match != null) {
            vp.verb = body.syntax;
            break;
          }
        }
      }
      if (vp.verb != null) {
        return vp.verb(this.scope, vp.object, vp.ref, vp.indirect);
      }
    };

    Parser.prototype.type = function(line) {
      var j, key, len, match, pattern, ref, ref1, sentence, value;
      sentence = {
        type: 'declarative',
        subtype: null
      };
      ref = this.dictionary.types.questions;
      for (key in ref) {
        value = ref[key];
        ref1 = value.patterns;
        for (j = 0, len = ref1.length; j < len; j++) {
          pattern = ref1[j];
          match = line.match(pattern);
          if (match != null) {
            sentence.type = 'question';
            sentence.subtype = key;
          }
        }
      }
      return sentence;
    };

    Parser.prototype.parse = function(line) {

      /* Remove ignored words */
      var j, len, ref, sentence, word;
      ref = this.dictionary.ignore;
      for (j = 0, len = ref.length; j < len; j++) {
        word = ref[j];
        line = line.replace(word + " ", "");
      }

      /* Find sentence type */
      sentence = this.type(line);
      if (sentence.type === 'question') {
        return this.question(line, sentence.subtype);
      } else {
        return this.vp(line);
      }
    };

    Parser.prototype.wrap = function(lines, comments, path) {
      var combined, document, i, j, ref;
      document = [];
      document.push("\n### Generated by PseudoScript 0.0.1 ###\n");
      document.push("\n### Imports ###");
      document.push("map = require '" + path + "'");
      document.push("\n# Abstracts #");
      document.push("Universe = map.abstracts.Universe");
      document.push("Noun = map.abstracts.Noun");
      document.push("\n# Concretes #");
      document.push("Room = map.concretes[0]");
      document.push("Light = map.concretes[1]\n");
      document.push("rooms = []");
      document.push("lights = []");
      document.push("\n\n\n### Code ###\n");
      document.push("# So you think you're god...");
      document.push("universe = new Universe()\n");
      combined = [];
      for (i = j = 0, ref = comments.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        combined.push("# " + comments[i] + "\n" + lines[i] + "\n");
      }
      document.push(combined.join("\n"));
      return document.join("\n");

      /*
      for model in @map.abstracts
        console.log model.toString()
      for model in @map.concretes
        console.log model.toString()
       */
    };

    return Parser;

  })();

  module.exports = Parser;

}).call(this);
