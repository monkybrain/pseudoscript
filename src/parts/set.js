// Generated by CoffeeScript 1.10.0
(function() {
  var Find, Scope, Set, modules;

  modules = require("../modules/modules");

  Find = require("./find");

  Scope = require("./scope");

  Set = (function() {
    function Set() {}

    Set.lexical = {
      base: 'set',
      synonyms: []
    };

    Set.parse = function(segment) {
      var current, i, index, indices, key, len, match, mod, module, object, operation, pattern, property, ref, ref1, usingScope, value;
      object = Find.object(segment);
      module = Find.module(segment);
      ref = Find.reference(segment);
      Scope.object = object;
      Scope.ref = ref;
      current = module;
      console.log(current);
      usingScope = false;
      if (object == null) {
        object = this.scope.object.type;
        ref = Find.reference(segment, object);
        if (ref != null) {
          this.scope.object.ref = ref;
        } else {
          ref = this.scope.object.ref;
        }
        for (i = 0, len = modules.length; i < len; i++) {
          mod = modules[i];
          if (object === mod.lexical.base) {
            module = mod;
            break;
          }
        }
        usingScope = true;
      }
      if (object == null) {
        console.error("No object");
        return {
          object: null
        };
      }
      ref1 = current.properties;
      for (key in ref1) {
        value = ref1[key];
        match = segment.match(key);
        if (match != null) {
          property = this.scope.property = key;
          break;
        }
      }
      if (property == null) {
        property = this.scope.property;
      }
      if (property == null) {
        console.error("No property specified");
        return;
      }
      indices = [
        {
          index: segment.indexOf(property),
          string: property
        }, {
          index: segment.indexOf(ref),
          string: ref
        }, {
          index: segment.indexOf(object),
          string: object
        }
      ];
      indices.sort(function(a, b) {
        return a.index < b.index;
      });
      index = indices[0];
      value = segment.slice(index.index + index.string.length + 1);
      pattern = /\bto\b/g;
      value = value.replace(pattern, "").trim();
      operation = {
        object: {
          type: current.self,
          ref: ref
        },
        property: property,
        value: value
      };
      return operation;
    };

    Set.split = function(text) {
      var parts, pattern;
      pattern = /and|,|&/g;
      parts = text.split(pattern);
      return parts.map(function(part) {
        return part.trim();
      });
    };

    Set.test = function(text) {
      var match, pattern, segments, split;
      pattern = /\bset .*( to)? \b(.*)\b/g;
      match = text.match(pattern);
      if (match != null) {
        split = this.split(match[0]);
        segments = split.map((function(_this) {
          return function(segment) {
            return _this.parse(segment);
          };
        })(this));
        return {
          type: 'verb',
          subtype: 'set',
          operations: segments
        };
      }
    };

    return Set;

  })();

  module.exports = Set;

}).call(this);
