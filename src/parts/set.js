// Generated by CoffeeScript 1.10.0
(function() {
  var Set, Util, modules;

  modules = require("../modules/modules");

  Util = require("./util");

  Set = (function() {
    function Set(dict) {
      this.dict = dict;
      this.scope = {
        object: {}
      };
    }

    Set.prototype.parse = function(segment) {
      var i, index, indices, j, key, len, len1, match, mod, module, object, operation, pattern, property, ref, ref1, usingScope, value;
      for (i = 0, len = modules.length; i < len; i++) {
        mod = modules[i];
        match = segment.match(mod.lexical.base);
        if (match != null) {
          object = mod.lexical.base;
          ref = Util.find.string(segment, object);
          this.scope.object.type = object;
          this.scope.object.ref = ref;
          module = mod;
          usingScope = false;
          break;
        }
      }
      if (object == null) {
        object = this.scope.object.type;
        ref = Util.find.string(segment, object);
        if (ref != null) {
          this.scope.object.ref = ref;
        } else {
          ref = this.scope.object.ref;
        }
        for (j = 0, len1 = modules.length; j < len1; j++) {
          mod = modules[j];
          if (object === mod.lexical.base) {
            module = mod;
            break;
          }
        }
        usingScope = true;
      }
      if (object == null) {
        console.error("No object");
        return {
          object: null
        };
      }
      ref1 = module.properties;
      for (key in ref1) {
        value = ref1[key];
        match = segment.match(key);
        if (match != null) {
          property = this.scope.property = key;
          break;
        }
      }
      if (property == null) {
        property = this.scope.property;
      }
      if (property == null) {
        console.error("No property specified");
        return;
      }
      indices = [
        {
          index: segment.indexOf(property),
          string: property
        }, {
          index: segment.indexOf(ref),
          string: ref
        }, {
          index: segment.indexOf(object),
          string: object
        }
      ];
      indices.sort(function(a, b) {
        return a.index < b.index;
      });
      index = indices[0];
      value = segment.slice(index.index + index.string.length + 1);
      pattern = /\bto\b/g;
      value = value.replace(pattern, "").trim();
      operation = {
        object: {
          type: module.self,
          ref: ref
        },
        property: property,
        value: value
      };
      return operation;
    };

    Set.prototype.split = function(text) {
      var parts, pattern;
      pattern = /and|,|&/g;
      parts = text.split(pattern);
      return parts.map(function(part) {
        return part.trim();
      });
    };

    Set.prototype.test = function(text) {
      var match, pattern, segments, split;
      pattern = /\bset .*( to)? \b(.*)\b/g;
      match = text.match(pattern);
      if (match != null) {
        split = this.split(match[0]);
        segments = split.map((function(_this) {
          return function(segment) {
            return _this.parse(segment);
          };
        })(this));
        return {
          type: 'verb',
          subtype: 'set',
          operations: segments
        };
      }
    };

    return Set;

  })();

  module.exports = Set;

}).call(this);
