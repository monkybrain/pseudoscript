// Generated by CoffeeScript 1.10.0

/* ADVERB: WHEN */


/* TODO: MOVE TO ADVERBS! */

(function() {
  var Adverb, Find, Module, Scope, When, dict, modules,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  modules = require("../../modules/modules");

  Module = require("../../modules/module");

  Scope = require("./../scope");

  Find = require("./../../core/find");

  Adverb = require("./../verbs/verb");

  dict = require("../../dictionaries/dictionary").adverbs;

  When = (function(superClass) {
    extend(When, superClass);

    function When() {
      return When.__super__.constructor.apply(this, arguments);
    }

    When.lexical = {
      base: 'when',
      synonyms: ['when']
    };

    When.types = dict['when'].types;

    When.split = function(text) {
      var parts, pattern;
      pattern = /\s+and\s+|,|\s+&\s+/g;
      parts = text.split(pattern);
      parts = parts.map(function(part) {
        return part.trim();
      });
      return parts.filter(function(part) {
        return part !== '';
      });
    };

    When.getObject = function(segment) {

      /* FIND OBJECT AND REFERENCE */
      var err, error, i, len, match, module, object, ref;
      for (i = 0, len = modules.length; i < len; i++) {
        module = modules[i];
        match = segment.match(module.lexical.base);
        if (match != null) {
          object = module.self;
          break;
        }
      }
      ref = Find.reference(segment);
      if (object == null) {
        if (ref != null) {
          try {
            object = Module.fetch(ref).module;
          } catch (error) {
            err = error;
            console.error("Error! '" + ref + "' not found.");
          }
        } else {
          object = Scope.current.object;
          ref = Scope.current.ref;
        }
      } else {
        ref = Scope.modules[object].ref;
      }
      return [object, ref];
    };

    When.getEvent = function(segment) {
      var i, key, len, module, ref1, value;
      for (i = 0, len = modules.length; i < len; i++) {
        module = modules[i];
        if (module.events != null) {
          ref1 = module.events;
          for (key in ref1) {
            value = ref1[key];
            return key;
          }
        }
      }
    };

    When.parse = function(segment) {
      var event, object, ref, ref1;
      ref1 = this.getObject(segment), object = ref1[0], ref = ref1[1];
      event = this.getEvent(segment);
      return [object, ref, event];
    };

    When.test = function(text) {
      var event, match, object, pattern, ref, ref1;
      pattern = /\bwhen\b/g;
      match = text.match(pattern);
      if (match != null) {
        ref1 = this.parse(match[0]), object = ref1[0], ref = ref1[1], event = ref1[2];
        return {
          type: 'adverb',
          adverb: 'when',
          object: object,
          ref: ref,
          event: event
        };
      }
    };

    When.syntax = function(phrase) {
      var adverb, close, event, object, open, ref;
      adverb = phrase.adverb, object = phrase.object, ref = phrase.ref, event = phrase.event;
      open = [];
      open.push("# On event '" + event + "' for '" + ref + "'");
      open.push(object + ".on '" + ref + "', '" + event + "', () ->\n");
      close = ["\n"];
      return [open, close];
    };

    return When;

  })(Adverb);

  module.exports = When;

}).call(this);
