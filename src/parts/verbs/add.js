// Generated by CoffeeScript 1.10.0
(function() {
  var Add, Find, Scope, Util, Verb,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Find = require("./../find");

  Scope = require("./../scope");

  Verb = require("./verb");

  Util = require("./../../core/util");

  Add = (function(superClass) {
    extend(Add, superClass);

    function Add() {
      return Add.__super__.constructor.apply(this, arguments);
    }

    Add.lexical = {
      base: 'add',
      synonyms: ['add', 'create'],
      regex: function() {
        var synonyms;
        synonyms = this.synonyms.map(function(synonym) {
          return synonym = "(" + synonym + ")";
        });
        return new RegExp("\\b(" + (synonyms.join("|")) + ")\\b", "g");
      }
    };

    Add.parse = function(text) {
      var direct, group, i, indirect, j, len, len1, match, noRefs, objects, pattern, ref, refs, results;
      direct = {};
      indirect = {};
      refs = Find.references(text);
      objects = Find.objects(text);
      match = text.match(/to/g);
      if (match != null) {
        group = objects.map(function(object) {
          return Find.word(object);
        });
        group = "(" + Util.regex.group(group) + ")";
        match = text.match(new RegExp("(to\\s+?)" + group));
        if (match != null) {
          indirect.object = match[2];
        }
        group = refs.map(function(ref) {
          return "'" + ref + "'";
        });
        group = "(" + Util.regex.group(group) + ")";
        match = text.match(new RegExp("(to\\s+?\\w+?\\s+?)" + group));
        if (match != null) {
          indirect.ref = match[2];
        }
        console.log(indirect.object);

        /*for ref in refs
          match = text.match new RegExp "to\\s+?'" + ref + "'", "g"
          if match?
            [indirect.ref] = match
         */
      }
      if (refs.length === 2) {
        for (i = 0, len = refs.length; i < len; i++) {
          ref = refs[i];
          pattern = new RegExp("to\\s+?" + ref, "g");
          match = text.match(pattern);
          if (match != null) {
            indirect.ref = ref;
            direct.ref = refs.filter(function(ref) {
              return ref !== indirect.ref;
            })[0];
          }
        }
      }
      console.log(direct);
      console.log(indirect);
      refs = Find.references(text);
      noRefs = text;
      results = [];
      for (j = 0, len1 = refs.length; j < len1; j++) {
        ref = refs[j];
        results.push(noRefs = noRefs.replace("'" + ref + "'", ""));
      }
      return results;

      /*
       * Find all objects
      objects = Find.objects noRefs
      
       * If only one object -> set as direct object
      if objects.length is 1
        [object] = objects
      
       * If two objects -> find direct and indirect objects
      if objects.length is 2
        group = Util.regex.group objects.map (object) -> Find.word object
        match = text.match group
      
        if match?
          console.log match
        prep = "to"
       */

      /*object = Find.object text
      ref = Find.reference text
      return [object, ref]
       */
    };

    Add.test = function(text) {
      var match, module, object, pattern, ref, ref1;
      pattern = this.lexical.regex();
      match = text.match(pattern);
      if (match != null) {
        ref1 = Add.parse(text), object = ref1[0], ref = ref1[1];
        module = Find.module(object);
        if (ref == null) {
          ref = module.lexical.base + module.index;
        }
        module.add(ref);
        Scope.modules[object] = {
          ref: ref
        };
        Scope.current = {
          object: object,
          ref: ref
        };
        return {
          type: 'verb',
          verb: 'add',
          object: object,
          ref: ref,
          input: text
        };
      }
    };

    Add.syntax = function(phrase) {
      var object, ref, syntax;
      object = phrase.object, ref = phrase.ref;
      return syntax = ["# Adding new " + object + " called '" + ref + "'", "new " + object + "('" + ref + "')\n"];
    };

    return Add;

  })(Verb);

  module.exports = Add;

}).call(this);
