// Generated by CoffeeScript 1.10.0

/* VERB: SET (BASED ON GET) */

(function() {
  var Find, Get, Scope, Set, modules,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  modules = require("../../modules/modules");

  Find = require("./../../core/find");

  Scope = require("./../scope");

  Get = require("./get");

  Set = (function(superClass) {
    extend(Set, superClass);

    function Set() {
      return Set.__super__.constructor.apply(this, arguments);
    }

    Set.lexical = {
      base: 'set',
      synonyms: ['set']
    };

    Set.getValue = function(segment, object, ref, property) {
      var err, error, index, match, module, occurrence, occurrences, pattern, type, value;
      module = Find.module(object);
      try {
        type = module.properties[property].type;
      } catch (error) {
        err = error;
        console.error("Error! Invalid property in segment '" + segment + "'");
      }
      if (type === 'number') {
        value = parseFloat(Find.number(segment));
      }
      if (type === 'string') {
        occurrences = [
          {
            string: module.lexical.base,
            index: segment.indexOf(module.lexical.base)
          }, {
            string: ref,
            index: segment.indexOf(ref)
          }, {
            string: property,
            index: segment.indexOf(property)
          }
        ];
        occurrences.sort(function(a, b) {
          return a.index < b.index;
        });
        occurrence = occurrences[0];
        value = segment.slice(occurrence.index + occurrence.string.length + 1);
        pattern = /(\bto\b)/;
        match = value.match(pattern);
        if (match != null) {
          index = match.index + "to".length;
          value = value.slice(index).trim();
        }
      }
      return value;
    };

    Set.parse = function(segment) {
      var object, property, ref, ref1, value;
      ref1 = this.getObject(segment), object = ref1[0], ref = ref1[1];
      property = this.getProperty(segment, object);
      value = this.getValue(segment, object, ref, property);
      Scope.current = {
        object: object,
        ref: ref,
        property: property,
        value: value
      };
      Scope.modules[object] = {
        ref: ref,
        property: property,
        value: value
      };
      return {
        object: object,
        ref: ref,
        property: property,
        value: value
      };
    };

    Set.test = function(text) {
      var match, pattern, segments, split;
      pattern = /\bset .*( to)? \b(.*)\b/g;
      match = text.match(pattern);
      if (match != null) {
        split = this.split(match[0]);
        segments = split.map((function(_this) {
          return function(segment) {
            return _this.parse(segment);
          };
        })(this));
        return {
          type: 'verb',
          verb: 'set',
          operations: segments,
          input: text
        };
      }
    };

    Set.syntax = function(phrase) {
      var i, len, object, operation, property, ref, ref1, syntax, value;
      syntax = [];
      ref1 = phrase.operations;
      for (i = 0, len = ref1.length; i < len; i++) {
        operation = ref1[i];
        object = operation.object, ref = operation.ref, property = operation.property, value = operation.value;
        syntax.push("# Setting '" + property + "' of '" + ref + "' to '" + value + "'");
        syntax.push(object + ".select('" + ref + "').set('" + property + "', '" + value + "')\n");
      }
      return syntax;
    };

    return Set;

  })(Get);

  module.exports = Set;

}).call(this);
