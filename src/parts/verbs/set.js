// Generated by CoffeeScript 1.10.0
(function() {
  var Find, Scope, Set, modules;

  modules = require("../../modules/modules");

  Find = require("./../find");

  Scope = require("./../scope");

  Set = (function() {
    function Set() {}

    Set.lexical = {
      base: 'set',
      synonyms: []
    };

    Set.parse = function(segment) {

      /* FIND OBJECT AND REFERENCE */
      var err, error, i, key, len, match, module, object, property, ref, ref1, type, value;
      for (i = 0, len = modules.length; i < len; i++) {
        module = modules[i];
        match = segment.match(module.lexical.base);
        if (match != null) {
          object = module.self;
          break;
        }
      }
      if (object == null) {
        object = Scope.current.object;
        ref = Scope.current.ref;
      } else {
        ref = Scope.modules[object].ref;
      }

      /* FIND PROPERTY */
      module = Find.module(object);
      ref1 = module.properties;
      for (key in ref1) {
        value = ref1[key];
        match = segment.match(key);
        if (match != null) {
          property = key;
        }
      }
      if (property == null) {
        property = Scope.modules[object].property;
      }

      /* FIND VALUE */
      try {
        type = module.properties[property].type;
      } catch (error) {
        err = error;
        console.error("Error! Invalid property in segment '" + segment + "'");
      }
      if (type === 'number') {
        value = parseFloat(Find.number(segment));
      }
      Scope.current = {
        object: object,
        ref: ref,
        property: property,
        value: value
      };
      Scope.modules[object] = {
        ref: ref,
        property: property,
        value: value
      };
      return {
        object: object,
        ref: ref,
        property: property,
        value: value
      };
    };

    Set.split = function(text) {
      var parts, pattern;
      pattern = /and|,|&/g;
      parts = text.split(pattern);
      return parts.map(function(part) {
        return part.trim();
      });
    };

    Set.test = function(text) {
      var match, pattern, segments, split;
      pattern = /\bset .*( to)? \b(.*)\b/g;
      match = text.match(pattern);
      if (match != null) {
        split = this.split(match[0]);
        segments = split.map((function(_this) {
          return function(segment) {
            return _this.parse(segment);
          };
        })(this));
        return {
          type: 'verb',
          subtype: 'set',
          operations: segments
        };
      }
    };

    return Set;

  })();

  module.exports = Set;

}).call(this);
