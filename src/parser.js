// Generated by CoffeeScript 1.10.0
(function() {
  var Finder, Parser, error, log, tools;

  tools = require("monky-tools");

  Finder = require("./finder");

  log = tools.console.log;

  error = tools.console.error;

  Parser = (function() {
    function Parser(dictionary, map) {
      this.dict = dictionary;
      this.map = map;
      this.find = new Finder(this.dict, this.map);
      this.scope = {
        verb: null,
        object: {
          type: null,
          ref: null
        },
        indirect: {
          "class": null,
          ref: null
        },
        property: null
      };
    }

    Parser.prototype.separate = function(line) {
      var clauses, conjunctions;
      line = line.toLowerCase();
      conjunctions = /( and )|(, )/g;
      clauses = line.split(conjunctions);
      clauses = clauses.filter(function(clause) {
        if (clause == null) {
          return false;
        }
        return !clause.match(conjunctions);
      });
      return clauses;
    };

    Parser.prototype.parse = function(line) {
      var adverb, clause, clauses, end, event, i, k2, lefthand, len, match, object, pattern, property, ref, ref1, result, righthand, start, text, type, unit, v2, value, verb;
      clauses = this.separate(line);
      clauses = clauses.map(function(clause) {
        return {
          text: clause
        };
      });
      for (i = 0, len = clauses.length; i < len; i++) {
        clause = clauses[i];

        /* ADVERB */
        adverb = this.find.adverb(clause.text);
        if (adverb != null) {
          clause.type = 'adverbial phrase';
          clause.adverb = adverb.type;
          match = clause.adverb.match(/(delay)|(interval)/g);
          if (match != null) {
            clause.value = this.find.value(clause.text);
            clause.unit = this.find.unit(clause.text);
          }
          continue;
        }

        /* EVENT */
        event = this.find.event(clause.text);
        if (event != null) {
          clause.type = 'event phrase';
          clause.object = event.object;
          clause.event = event.event;
          continue;
        }

        /* CONDITIONALS */
        result = this.find.conditional(clause.text);
        if (result != null) {
          text = clause.text;
          clause.type = 'conditional phrase';
          clause.subtype = result.type;
          if (result.type === 'if') {
            ref1 = this.dict.comparisons;
            for (k2 in ref1) {
              v2 = ref1[k2];
              pattern = new RegExp(k2);
              match = text.match(pattern);
              if (match != null) {
                clause.test = v2.type;
                pattern = /if .*? is/;
                if (match != null) {
                  start = text.indexOf("if") + "if".length;
                  end = text.indexOf("is");
                  lefthand = text.slice(start, end).trim();
                  start = text.indexOf("than") + "than".length;
                  righthand = text.slice(start).trim();
                  if (!isNaN(lefthand)) {
                    lefthand = parseFloat(lefthand);
                  }
                  if (!isNaN(righthand)) {
                    righthand = parseFloat(righthand);
                  }
                  clause.lefthand = lefthand;
                  clause.righthand = righthand;
                  console.log(clause);
                }
              }
            }
          }
          continue;
        }

        /* VERB */
        verb = this.find.verb(clause.text);
        if (verb != null) {
          clause.type = 'verb phrase';
          this.scope.verb = clause.verb = verb.type;
          if (verb.property != null) {
            this.scope.property = clause.property = verb.property;
          }
          if (verb.value != null) {
            this.scope.value = clause.value = verb.value;
          }
        } else {
          clause.verb = this.scope.verb;
        }

        /* OBJECT - REFERENCE */
        ref = this.find.reference(clause.text);
        if (ref != null) {
          object = {
            ref: ref
          };
          this.scope.object = clause.object = object;
        } else {
          clause.object = this.scope.object;
        }

        /* OBJECT - TYPE */
        type = this.find.object(clause.text);
        if (type != null) {
          if (object != null) {
            object.type = type;
          } else {
            object = {
              type: type
            };
          }
          this.scope.object = clause.object = object;
        } else {
          clause.object = this.scope.object;
        }

        /* PROPERTY */
        property = this.find.property(clause.text, this.scope.object.type);
        if (property != null) {
          this.scope.property = clause.property = property;
        } else {
          clause.property = this.scope.property;
        }

        /* VALUE */
        value = this.find.value(clause.text);
        if (value != null) {
          value = isNaN(parseFloat(value)) ? value : parseFloat(value);
          this.scope.value = clause.value = value;
        } else {
          clause.value = this.scope.value;
        }

        /* UNITS */
        if (typeof clause.value === 'number') {
          unit = this.find.unit(clause.text);
          if (unit != null) {
            this.scope.unit = clause.unit = unit;
          } else {
            clause.unit = this.scope.unit;
          }
        }
      }
      return clauses;
    };

    return Parser;

  })();

  module.exports = Parser;

}).call(this);
