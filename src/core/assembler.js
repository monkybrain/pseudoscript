// Generated by CoffeeScript 1.10.0
(function() {
  var Assembler, adverbs, verbs,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  verbs = require("./../parts/verbs/verbs");

  adverbs = require("./../parts/adverbs/adverbs");

  Assembler = (function() {
    function Assembler() {}

    Assembler.indent = {
      interval: 2,
      level: 0,
      inc: function() {
        return this.level += 2;
      },
      dec: function() {
        return this.level -= 2;
      },
      set: function(level) {
        return this.level = level;
      },
      exec: function(syntax) {
        var i, indent, j, ref1;
        indent = "";
        for (i = j = 0, ref1 = this.level; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
          indent += " ";
        }
        return indent + syntax;
      }
    };

    Assembler.chain = {
      level: 0,
      inc: function() {
        return this.level += 1;
      },
      reset: function() {
        return this.level = 0;
      },
      close: false,
      error: {
        comment: "# Catch errors",
        syntax: ".catch (err) -> Util.error err\n"
      }
    };

    Assembler.action = function(phrase, level) {
      var action, object, prefix, ref, syntax;
      action = phrase.action, object = phrase.object, ref = phrase.ref;
      prefix = level !== 0 ? ".then -> " : "";
      syntax = [];
      syntax.push("# Performing action '" + action + "'");
      syntax.push(prefix + (object + ".do '" + ref + "', '" + action + "'\n"));
      return syntax;
    };

    Assembler.parse = function(segment) {
      var adverb, close, closure, closures, index, j, k, l, len, len1, len2, len3, len4, len5, len6, line, m, n, o, open, p, phrase, previous, ref1, ref2, ref3, ref4, ref5, syntax, verb;
      syntax = [];
      closures = [];
      previous = {
        type: null,
        verb: null
      };
      for (index = j = 0, len = segment.length; j < len; index = ++j) {
        phrase = segment[index];
        if (phrase.type === 'verb') {
          for (k = 0, len1 = verbs.length; k < len1; k++) {
            verb = verbs[k];
            if (phrase.verb === verb.lexical.base) {
              ref1 = verb.syntax(phrase, this.chain.level);
              for (l = 0, len2 = ref1.length; l < len2; l++) {
                line = ref1[l];
                syntax.push(this.indent.exec(line));
              }
              if (phrase.verb === 'add') {
                continue;
              }
              this.chain.inc();
              if (index === segment.length - 1) {
                syntax.push(this.indent.exec(this.chain.error.comment));
                syntax.push(this.indent.exec(this.chain.error.syntax));
                this.chain.reset();
                this.chain.close = false;
              } else {
                this.chain.close = true;
              }
            }
          }
        } else if (phrase.type === 'action') {
          ref2 = this.action(phrase, this.chain.level);
          for (m = 0, len3 = ref2.length; m < len3; m++) {
            line = ref2[m];
            syntax.push(this.indent.exec(line));
          }
          this.chain.inc();
        } else if (phrase.type === 'adverb') {
          for (n = 0, len4 = adverbs.length; n < len4; n++) {
            adverb = adverbs[n];
            if (this.chain.close) {
              syntax.push(this.indent.exec(this.chain.error.comment));
              syntax.push(this.indent.exec(this.chain.error.syntax));
              this.chain.reset();
              this.chain.close = false;
            }
            if (ref3 = phrase.adverb, indexOf.call(Object.keys(adverb.types), ref3) >= 0) {
              ref4 = adverb.syntax(phrase, this.chain.level), open = ref4[0], close = ref4[1];
              for (o = 0, len5 = open.length; o < len5; o++) {
                line = open[o];
                syntax.push(this.indent.exec(line));
              }
              closures.push(close);
              this.indent.inc();
              this.chain.reset();
            }
          }
        }
      }
      ref5 = closures.reverse();
      for (p = 0, len6 = ref5.length; p < len6; p++) {
        closure = ref5[p];
        this.indent.dec();
        syntax.push(this.indent.exec(closure));
      }
      return syntax.join("\n");
    };

    Assembler.wrap = function(code) {
      var imports, j, len, module, modules;
      imports = ["### generated by pseudoscript 0.1 ###\n"];
      imports.push("# Core modules");
      imports.push("Util = require '../src/core/runtime/util'");
      imports.push("Globals = require '../src/core/runtime/globals'\n");
      modules = [
        {
          name: 'Light',
          path: '../src/modules/light'
        }, {
          name: 'Room',
          path: '../src/modules/room'
        }, {
          name: 'Shaker',
          path: '../src/modules/shaker'
        }
      ];
      imports.push("# Custom modules");
      for (j = 0, len = modules.length; j < len; j++) {
        module = modules[j];
        imports.push(module.name + " = require '" + module.path + "'");
      }
      imports[imports.length - 1] = imports[imports.length - 1] + "\n";
      code = imports.concat(code);
      return code;
    };

    return Assembler;

  })();

  module.exports = Assembler;

}).call(this);
